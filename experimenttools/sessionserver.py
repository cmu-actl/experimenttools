"""Serve a session or set of sessions.

`python -m experimenttools.sessionserver SESSION_DIR [SESSION_DIR...]`
serves the experiments saved in each `SESSION_DIR` together.

"""
import contextlib
import http.server
import os
import socket
from pathlib import Path

from experimenttools import Session


class SessionServer:
    """Handles serving of session files.

    Allows for multiple sessions to be displayed on the same server. Gathers
    the html files generated by each session and links them to an output
    directory. Then, that directory can be served.

    Examples
    --------
    >>> import experimenttools as et
    >>> import tempfile
    >>> m0 = et.metrics.NumericMetric("m0")
    >>> session_dir = tempfile.mkdtemp()
    >>> server_dir = tempfile.mkdtemp()
    >>> session = et.Session(session_dir, name="sess", metrics=[m0])
    >>> server = et.SessionServer([session], server_dir)
    >>> for i in range(5):
    ...     m0(i)
    >>> session.plot() # Writes plots to 'experiment/index.html'

    Then, run `python -m experimenttools.sessionserver SESSION_DIR` to serve the
    sessions while experiments are running. Or, do it programatically using
    `server.serve()` at the end of the experiment.

    Alternatively, you can pass in a list of
    `(session_name, session_output_dir)` tuples to `SessionServer`
    >>> session_spec = (session.name, session.output_dir)
    >>> server = et.SessionServer([session_spec], server_dir)

    """

    def __init__(self, sessions, output_dir):
        self.output_dir = Path(output_dir)
        for session in sessions:
            self.add_session(session)

    def add_session(self, session):
        """Add a session to the server.

        Parameters
        ----------
        session : Sesssion or (str, str)
                The `Session` to add. If passing in a `Session`, the session
                will be updated before it is added to ensure that its outputs
                have been created. If `(str, str)`, the first `str` should be
                the session name and the second should be the session output
                directory. Ensure that session has been updated if using this
                method.

        """
        if isinstance(session, Session):
            if session.name is None:
                raise ValueError(
                    "Sessions must have names to be added to a session server."
                )
            # Update the session so that index.html is generated
            session.update()
            sess_name = session.name
            sess_output_dir = session.output_dir
        else:
            sess_name, sess_output_dir = session
            sess_output_dir = Path(sess_output_dir)
        self.output_dir.mkdir(exist_ok=True, parents=True)
        src_html_path = sess_output_dir / "index.html"
        dest_html_path = self.output_dir / f"{sess_name}.html"
        if dest_html_path.is_file():
            dest_html_path.unlink()
        os.link(src_html_path, dest_html_path)

    def serve(self, port=8000, bind="127.0.0.1"):
        """Start the server.

        Parameters
        ----------
        port: int
                The port to serve to.
        bind: str
                The bind address.

        """
        output_dir = self.output_dir

        class DualStackServer(http.server.ThreadingHTTPServer):
            def server_bind(self):
                # suppress exception when protocol is IPv4
                with contextlib.suppress(Exception):
                    self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
                return super().server_bind()

            def finish_request(self, request, client_address):
                self.RequestHandlerClass(
                    request, client_address, self, directory=str(output_dir)
                )

        _run_server(ServerClass=DualStackServer, port=port, bind=bind)


def _run_server(ServerClass, protocol="HTTP/1.0", port=8000, bind=None):
    HandlerClass = http.server.SimpleHTTPRequestHandler
    ServerClass.address_family, addr = http.server._get_best_family(bind, port)
    HandlerClass.protocol_version = protocol
    with ServerClass(addr, HandlerClass) as httpd:
        host, port = httpd.socket.getsockname()[:2]
        url_host = f"[{host}]" if ":" in host else host
        print(f"Serving HTTP on {host} port {port} " f"(http://{url_host}:{port}/) ...")
        httpd.serve_forever()


if __name__ == "__main__":
    import argparse
    import tempfile

    parser = argparse.ArgumentParser(description="Serve a set of sessions.")
    parser.add_argument("session_dir", nargs="+", help="Session directory to serve.")
    parser.add_argument(
        "--session_name",
        nargs="+",
        help="Optional name for each 'session_dir'. If not specified, the parent "
        "directory of each 'session_dir' is used as the name.",
    )
    parser.add_argument("--port", type=int, default=8888, help="Port to serve to.")
    parser.add_argument("--bind", default="127.0.0.1", help="Bind address for serving.")
    args = parser.parse_args()

    if args.session_name:
        if len(args.session_name) != len(args.session_dir):
            raise ValueError(
                "Number of 'session_name's specified must match number of "
                "'session_dir's"
            )
        session_name = args.session_name
    else:
        session_name = [Path(sd).parent.name for sd in args.session_dir]

    # Create local temporary directory to prevent cross-device links
    local_tmp = Path(".tmp").resolve()
    try:
        local_tmp.mkdir(exist_ok=True)
        with tempfile.TemporaryDirectory(
            prefix="experimenttools_server", dir=local_tmp
        ) as tmp_dir:
            server = SessionServer(zip(session_name, args.session_dir), tmp_dir)
            server.serve(port=args.port, bind=args.bind)
    except (KeyboardInterrupt, OSError) as e:
        # Remove local temp directory if empty
        try:
            local_tmp.rmdir()
        except OSError:
            pass
        if isinstance(e, OSError):
            raise e
