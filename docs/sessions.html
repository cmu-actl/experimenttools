<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>experimenttools.sessions API documentation</title>
<meta name="description" content="Keep track of an experiment session â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>experimenttools.sessions</code></h1>
</header>
<section id="section-intro">
<p>Keep track of an experiment session.</p>
<p><code>Sesssion</code> objects can hold a set of metrics so they can be plotted and
serialized together.</p>
<p><code><a title="experimenttools.sessions.SessionManager" href="#experimenttools.sessions.SessionManager">SessionManager</a></code> objects can manage the automatic periodic updating of
<code><a title="experimenttools.sessions.Session" href="#experimenttools.sessions.Session">Session</a></code> outputs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Keep track of an experiment session.

`Sesssion` objects can hold a set of metrics so they can be plotted and
serialized together.

`SessionManager` objects can manage the automatic periodic updating of
`Session` outputs.

&#34;&#34;&#34;
import contextlib
import http.server
import os
import socket
import time
from datetime import datetime
from pathlib import Path

import holoviews as hv

from experimenttools.callbacks import LambdaSessionCallback
from experimenttools.metrics import PlottableMetric, SerializableMetric

hv.extension(&#34;bokeh&#34;)


class Session:
    &#34;&#34;&#34;Stores, plots, and serializes a collection of `Metric` objects.

    Examples
    --------
    &gt;&gt;&gt; import experimenttools as et
    &gt;&gt;&gt; import tempfile
    &gt;&gt;&gt; m0 = et.metrics.NumericMetric(&#34;m0&#34;)
    &gt;&gt;&gt; m1 = et.metrics.NumericMetric(&#34;m1&#34;)
    &gt;&gt;&gt; session_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; session = et.Session(session_dir, metrics=[m0, m1])
    &gt;&gt;&gt; for i in range(5):
    ...     m0(i)
    ...     m1(2*i)
    &gt;&gt;&gt; session.plot() # Writes plots to &#39;experiment/index.html&#39;
    &gt;&gt;&gt; session.serialize() # Writes to &#39;experiments/serialized&#39;

    &#34;&#34;&#34;

    def __init__(
        self,
        output_dir,
        name=None,
        metrics=None,
        callbacks=None,
        plot_metrics=True,
        serialize_metrics=True,
    ):
        &#34;&#34;&#34;Create a new experiment session.

        Parameters
        ----------
        output_dir: path-like object
                Directory to store session data in.
        name: str
                Name of the session, used if serving multiple sessions.
        metrics: list of Metric
                The metrics to mointor.
        callbacks: list of Sessioncallback
                callbacks to add to the session.
        plot_metrics: bool
                Whether or not to plots metrics.
        serialize_metrics: bool
                Whether or not to save metrics to files.

        &#34;&#34;&#34;
        self.output_dir = Path(output_dir)
        self.name = name

        self.callbacks = []
        if callbacks:
            for callback in callbacks:
                self.add_callback(callback)
        self.call_callbacks(lambda h: h.on_session_start())

        self._metrics = []
        if metrics:
            for metric in metrics:
                self.add_metric(metric)

        self._update_actions = []
        if plot_metrics:
            self._update_actions.append(self.plot)
        if serialize_metrics:
            self._update_actions.append(self.serialize)

    @property
    def metrics(self):
        &#34;&#34;&#34;Get the metrics tracked by this session.&#34;&#34;&#34;
        return self._metrics

    def add_metric(self, metric):
        &#34;&#34;&#34;Add a metric to the session.&#34;&#34;&#34;
        if metric.name in [m.name for m in self._metrics]:
            raise ValueError(f&#34;Session already has metric with name: {metric.name}&#34;)
        self._metrics.append(metric)
        self.call_callbacks(lambda h: h.on_metric_add(metric))

    def add_callback(self, callback):
        &#34;&#34;&#34;Add a `SessionCallback` to the session.&#34;&#34;&#34;
        callback.set_session(self)
        self.callbacks.append(callback)

    def remove_callback(self, callback):
        &#34;&#34;&#34;Remove a `SessionCallback` from the session.&#34;&#34;&#34;
        self.callbacks.remove(callback)

    def call_callbacks(self, fn):
        &#34;&#34;&#34;Call a function with each callback as an argument.&#34;&#34;&#34;
        for callback in self.callbacks:
            fn(callback)

    def update(self):
        &#34;&#34;&#34;Update the session outputs.&#34;&#34;&#34;
        for action in self._update_actions:
            action()
        self.call_callbacks(lambda h: h.on_update())

    def plot(self):
        &#34;&#34;&#34;Plot all plottable metrics.&#34;&#34;&#34;
        self.output_dir.mkdir(exist_ok=True, parents=True)
        plots = []
        for metric in self._metrics:
            if isinstance(metric, PlottableMetric):
                plots.append(metric.plot())
        layout = hv.Layout(plots)
        hv.save(layout, self.output_dir / &#34;index.html&#34;)

    def serialize(self):
        &#34;&#34;&#34;Serialize all serializable metrics.&#34;&#34;&#34;
        self.output_dir.mkdir(exist_ok=True, parents=True)
        serialize_dir = self.output_dir / &#34;serialized&#34;
        serialize_dir.mkdir(exist_ok=True)
        for metric in self._metrics:
            if isinstance(metric, SerializableMetric):
                metric.serialize(serialize_dir / metric.name)


class SessionManager:
    &#34;&#34;&#34;Manages the updating of a `Session`.

    A `SessionManager` does not begin managing until `manage` is called.
    At that point, it will continue managing until `close` is called.
    Alternatively, the `SesssionManager` can be used as a context manager.

    Examples
    --------
    &gt;&gt;&gt; import experimenttools as et
    &gt;&gt;&gt; import tempfile
    &gt;&gt;&gt; m0 = et.metrics.NumericMetric(&#34;m0&#34;)
    &gt;&gt;&gt; session_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; session = et.Session(session_dir, metrics=[m0])
    &gt;&gt;&gt; manager = et.SessionManager(session, update_type=&#34;updates&#34;)
    &gt;&gt;&gt; _ = manager.manage()
    &gt;&gt;&gt; for i in range(120):
    ...     m0(i) # m0 will be plotted and serialized every 60th update
    &gt;&gt;&gt; manager.close()

    As a context manager
    &gt;&gt;&gt; with SessionManager(session, update_type=&#34;updates&#34;).manage():
    ...     for i in range(120):
    ...         m0(i)
    &gt;&gt;&gt; m0(1) # Manager no longer managing the session

    &gt;&gt;&gt; manager = SessionManager(session, update_type=&#34;updates&#34;)
    &gt;&gt;&gt; with manager.manage():
    ...     for i in range(120):
    ...         m0(i)

    &#34;&#34;&#34;

    def __init__(self, session, update_type=&#34;seconds&#34;, update_freq=60, verbose=0):
        &#34;&#34;&#34;Create a new session manager.

        Parameters
        ----------
        session: Session
                The session to manage.
        update_type: str
                Either &#39;seconds&#39; or &#39;updates&#39;. If &#39;seconds&#39;, session will be
                updated every `update_freq` seconds. If &#39;updates&#39; session
                will be updated every `update_freq` total updates to
                metrics.
        update_freq: int
                The frequency for updating the session.
        verbose: int
                0, 1, or 2. 0 = silent, 1 = warnings, 2 = info.

        &#34;&#34;&#34;
        self._verbose = verbose
        self._session = session
        self._managing = False
        self._session_callback = LambdaSessionCallback(
            on_metric_add=lambda m: m.add_callback(self.process_metric_update)
        )
        if update_type == &#34;seconds&#34;:
            self._last_update_seconds = time.time()
        elif update_type == &#34;updates&#34;:
            self._num_updates = 0
        else:
            raise ValueError(
                f&#34;Uknown value for parameter &#39;update_type&#39;: &#39;{update_type}&#39;&#34;
            )
        self._update_freq = update_freq
        self._log(2, f&#34;Session outputting to {self._session.output_dir}&#34;)

    def _log(self, level, msg):
        if self._verbose &gt;= level:
            print(f&#34;{datetime.now()}: expeexperimenttools.SessionManager] {msg}&#34;)

    def manage(self):
        &#34;&#34;&#34;Beginning managing the sesssion.

        Allows the manager to update the session when metrics are updated.

        Raises
        ------
        RuntimeError
                If the manager has already begun to manage the session.

        &#34;&#34;&#34;
        if self._managing:
            raise RuntimeError(&#34;SessionManager is already managing&#34;)
        self._log(2, &#34;Beginning management&#34;)
        self._managing = True
        self._session.add_callback(self._session_callback)
        for m in self._session.metrics:
            m.add_callback(self.process_metric_update)
        return self

    def close(self):
        &#34;&#34;&#34;Stop managing the session.

        The manager will no longer update the session when metrics have
        been updated.

        Raises
        ------
        RuntimeError
                If the manager is not currently managing the session.

        &#34;&#34;&#34;
        if not self._managing:
            raise RuntimeError(&#34;SessionManager is already closed&#34;)
        self._log(2, &#34;Ending management&#34;)
        self._session.remove_callback(self._session_callback)
        for m in self._session.metrics:
            m.remove_callback(self.process_metric_update)

    @property
    def session(self):
        &#34;&#34;&#34;Get the sesssion being managed.&#34;&#34;&#34;
        return self._session

    def __enter__(self):
        &#34;&#34;&#34;Use the session manager as a context manager.&#34;&#34;&#34;
        if not self._managing:
            raise RuntimeError(&#34;Use &#39;with manager.manage()&#39; for context management&#34;)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        &#34;&#34;&#34;Close the session manager upon exiting the context.&#34;&#34;&#34;
        self.close()

    def process_metric_update(self, _):
        &#34;&#34;&#34;Update the session if the update frequency has been reached.&#34;&#34;&#34;
        try:
            if time.time() - self._last_update_seconds &gt;= self._update_freq:
                self._log(2, &#34;Updating session&#34;)
                self._session.update()
                self._last_update_seconds = time.time()
        except AttributeError:
            if self._num_updates + 1 &gt;= self._update_freq:
                self._log(2, &#34;Updating session&#34;)
                self._session.update()
                self._num_updates = 0
            else:
                self._num_updates += 1


class SessionServer:
    &#34;&#34;&#34;Handles serving of session files.

    Allows for multiple sessions to be displayed on the same server. Gathers
    the html files generated by each session and links them to an output
    directory. Then, that directory can be served.

    Examples
    --------
    &gt;&gt;&gt; import experimenttools as et
    &gt;&gt;&gt; import tempfile
    &gt;&gt;&gt; m0 = et.metrics.NumericMetric(&#34;m0&#34;)
    &gt;&gt;&gt; session_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; server_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; session = et.Session(session_dir, name=&#34;sess&#34;, metrics=[m0])
    &gt;&gt;&gt; server = et.SessionServer([session], server_dir)
    &gt;&gt;&gt; for i in range(5):
    ...     m0(i)
    &gt;&gt;&gt; session.plot() # Writes plots to &#39;experiment/index.html&#39;

    Then, run `python -m http.server --directory SERVER_DIR` to serve the
    sessions while experiments are running. Or, do it programatically using
    `server.serve()` at the end of the experiment.

    Alternatively, you can pass in a list of
    `(session_name, session_output_dir)` tuples to `SessionServer`
    &gt;&gt;&gt; session_spec = (session.name, session.output_dir)
    &gt;&gt;&gt; server = et.SessionServer([session_spec], server_dir)

    &#34;&#34;&#34;

    def __init__(self, sessions, output_dir):
        self.output_dir = Path(output_dir)
        for session in sessions:
            self.add_session(session)

    def add_session(self, session):
        &#34;&#34;&#34;Add a session to the server.

        Parameters
        ----------
        session : Sesssion or (str, str)
                The `Session` to add. If passing in a `Session`, the session
                will be updated before it is added to ensure that its outputs
                have been created. If `(str, str)`, the first `str` should be
                the session name and the second should be the session output
                directory. Ensure that session has been updated if using this
                method.

        &#34;&#34;&#34;
        if isinstance(session, Session):
            if session.name is None:
                raise ValueError(
                    &#34;Sessions must have names to be added to a session server.&#34;
                )
            # Update the session so that index.html is generated
            session.update()
            sess_name = session.name
            sess_output_dir = session.output_dir
        else:
            sess_name, sess_output_dir = session
        self.output_dir.mkdir(exist_ok=True, parents=True)
        src_html_path = sess_output_dir / &#34;index.html&#34;
        dest_html_path = self.output_dir / f&#34;{sess_name}.html&#34;
        if dest_html_path.is_file():
            dest_html_path.unlink()
        os.link(src_html_path, dest_html_path)

    def serve(self, port=8000, bind=&#34;127.0.0.1&#34;):
        &#34;&#34;&#34;Start the server.

        Parameters
        ----------
        port: int
                The port to serve to.
        bind: str
                The bind address.

        &#34;&#34;&#34;
        output_dir = self.output_dir

        class DualStackServer(http.server.ThreadingHTTPServer):
            def server_bind(self):
                # suppress exception when protocol is IPv4
                with contextlib.suppress(Exception):
                    self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
                return super().server_bind()

            def finish_request(self, request, client_address):
                self.RequestHandlerClass(
                    request, client_address, self, directory=str(output_dir)
                )

        http.server.test(
            HandlerClass=http.server.SimpleHTTPRequestHandler,
            ServerClass=DualStackServer,
            port=port,
            bind=bind,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="experimenttools.sessions.Session"><code class="flex name class">
<span>class <span class="ident">Session</span></span>
<span>(</span><span>output_dir, name=None, metrics=None, callbacks=None, plot_metrics=True, serialize_metrics=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores, plots, and serializes a collection of <code>Metric</code> objects.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import experimenttools as et
&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; m0 = et.metrics.NumericMetric(&quot;m0&quot;)
&gt;&gt;&gt; m1 = et.metrics.NumericMetric(&quot;m1&quot;)
&gt;&gt;&gt; session_dir = tempfile.mkdtemp()
&gt;&gt;&gt; session = et.Session(session_dir, metrics=[m0, m1])
&gt;&gt;&gt; for i in range(5):
...     m0(i)
...     m1(2*i)
&gt;&gt;&gt; session.plot() # Writes plots to 'experiment/index.html'
&gt;&gt;&gt; session.serialize() # Writes to 'experiments/serialized'
</code></pre>
<p>Create a new experiment session.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_dir</code></strong> :&ensp;<code>path-like object</code></dt>
<dd>Directory to store session data in.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the session, used if serving multiple sessions.</dd>
<dt><strong><code>metrics</code></strong> :&ensp;<code>list</code> of <code>Metric</code></dt>
<dd>The metrics to mointor.</dd>
<dt><strong><code>callbacks</code></strong> :&ensp;<code>list</code> of <code>Sessioncallback</code></dt>
<dd>callbacks to add to the session.</dd>
<dt><strong><code>plot_metrics</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to plots metrics.</dd>
<dt><strong><code>serialize_metrics</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to save metrics to files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Session:
    &#34;&#34;&#34;Stores, plots, and serializes a collection of `Metric` objects.

    Examples
    --------
    &gt;&gt;&gt; import experimenttools as et
    &gt;&gt;&gt; import tempfile
    &gt;&gt;&gt; m0 = et.metrics.NumericMetric(&#34;m0&#34;)
    &gt;&gt;&gt; m1 = et.metrics.NumericMetric(&#34;m1&#34;)
    &gt;&gt;&gt; session_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; session = et.Session(session_dir, metrics=[m0, m1])
    &gt;&gt;&gt; for i in range(5):
    ...     m0(i)
    ...     m1(2*i)
    &gt;&gt;&gt; session.plot() # Writes plots to &#39;experiment/index.html&#39;
    &gt;&gt;&gt; session.serialize() # Writes to &#39;experiments/serialized&#39;

    &#34;&#34;&#34;

    def __init__(
        self,
        output_dir,
        name=None,
        metrics=None,
        callbacks=None,
        plot_metrics=True,
        serialize_metrics=True,
    ):
        &#34;&#34;&#34;Create a new experiment session.

        Parameters
        ----------
        output_dir: path-like object
                Directory to store session data in.
        name: str
                Name of the session, used if serving multiple sessions.
        metrics: list of Metric
                The metrics to mointor.
        callbacks: list of Sessioncallback
                callbacks to add to the session.
        plot_metrics: bool
                Whether or not to plots metrics.
        serialize_metrics: bool
                Whether or not to save metrics to files.

        &#34;&#34;&#34;
        self.output_dir = Path(output_dir)
        self.name = name

        self.callbacks = []
        if callbacks:
            for callback in callbacks:
                self.add_callback(callback)
        self.call_callbacks(lambda h: h.on_session_start())

        self._metrics = []
        if metrics:
            for metric in metrics:
                self.add_metric(metric)

        self._update_actions = []
        if plot_metrics:
            self._update_actions.append(self.plot)
        if serialize_metrics:
            self._update_actions.append(self.serialize)

    @property
    def metrics(self):
        &#34;&#34;&#34;Get the metrics tracked by this session.&#34;&#34;&#34;
        return self._metrics

    def add_metric(self, metric):
        &#34;&#34;&#34;Add a metric to the session.&#34;&#34;&#34;
        if metric.name in [m.name for m in self._metrics]:
            raise ValueError(f&#34;Session already has metric with name: {metric.name}&#34;)
        self._metrics.append(metric)
        self.call_callbacks(lambda h: h.on_metric_add(metric))

    def add_callback(self, callback):
        &#34;&#34;&#34;Add a `SessionCallback` to the session.&#34;&#34;&#34;
        callback.set_session(self)
        self.callbacks.append(callback)

    def remove_callback(self, callback):
        &#34;&#34;&#34;Remove a `SessionCallback` from the session.&#34;&#34;&#34;
        self.callbacks.remove(callback)

    def call_callbacks(self, fn):
        &#34;&#34;&#34;Call a function with each callback as an argument.&#34;&#34;&#34;
        for callback in self.callbacks:
            fn(callback)

    def update(self):
        &#34;&#34;&#34;Update the session outputs.&#34;&#34;&#34;
        for action in self._update_actions:
            action()
        self.call_callbacks(lambda h: h.on_update())

    def plot(self):
        &#34;&#34;&#34;Plot all plottable metrics.&#34;&#34;&#34;
        self.output_dir.mkdir(exist_ok=True, parents=True)
        plots = []
        for metric in self._metrics:
            if isinstance(metric, PlottableMetric):
                plots.append(metric.plot())
        layout = hv.Layout(plots)
        hv.save(layout, self.output_dir / &#34;index.html&#34;)

    def serialize(self):
        &#34;&#34;&#34;Serialize all serializable metrics.&#34;&#34;&#34;
        self.output_dir.mkdir(exist_ok=True, parents=True)
        serialize_dir = self.output_dir / &#34;serialized&#34;
        serialize_dir.mkdir(exist_ok=True)
        for metric in self._metrics:
            if isinstance(metric, SerializableMetric):
                metric.serialize(serialize_dir / metric.name)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="experimenttools.sessions.Session.metrics"><code class="name">var <span class="ident">metrics</span></code></dt>
<dd>
<div class="desc"><p>Get the metrics tracked by this session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metrics(self):
    &#34;&#34;&#34;Get the metrics tracked by this session.&#34;&#34;&#34;
    return self._metrics</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="experimenttools.sessions.Session.add_callback"><code class="name flex">
<span>def <span class="ident">add_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a <code>SessionCallback</code> to the session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_callback(self, callback):
    &#34;&#34;&#34;Add a `SessionCallback` to the session.&#34;&#34;&#34;
    callback.set_session(self)
    self.callbacks.append(callback)</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.Session.add_metric"><code class="name flex">
<span>def <span class="ident">add_metric</span></span>(<span>self, metric)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a metric to the session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metric(self, metric):
    &#34;&#34;&#34;Add a metric to the session.&#34;&#34;&#34;
    if metric.name in [m.name for m in self._metrics]:
        raise ValueError(f&#34;Session already has metric with name: {metric.name}&#34;)
    self._metrics.append(metric)
    self.call_callbacks(lambda h: h.on_metric_add(metric))</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.Session.call_callbacks"><code class="name flex">
<span>def <span class="ident">call_callbacks</span></span>(<span>self, fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Call a function with each callback as an argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_callbacks(self, fn):
    &#34;&#34;&#34;Call a function with each callback as an argument.&#34;&#34;&#34;
    for callback in self.callbacks:
        fn(callback)</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.Session.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all plottable metrics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):
    &#34;&#34;&#34;Plot all plottable metrics.&#34;&#34;&#34;
    self.output_dir.mkdir(exist_ok=True, parents=True)
    plots = []
    for metric in self._metrics:
        if isinstance(metric, PlottableMetric):
            plots.append(metric.plot())
    layout = hv.Layout(plots)
    hv.save(layout, self.output_dir / &#34;index.html&#34;)</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.Session.remove_callback"><code class="name flex">
<span>def <span class="ident">remove_callback</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a <code>SessionCallback</code> from the session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_callback(self, callback):
    &#34;&#34;&#34;Remove a `SessionCallback` from the session.&#34;&#34;&#34;
    self.callbacks.remove(callback)</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.Session.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize all serializable metrics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self):
    &#34;&#34;&#34;Serialize all serializable metrics.&#34;&#34;&#34;
    self.output_dir.mkdir(exist_ok=True, parents=True)
    serialize_dir = self.output_dir / &#34;serialized&#34;
    serialize_dir.mkdir(exist_ok=True)
    for metric in self._metrics:
        if isinstance(metric, SerializableMetric):
            metric.serialize(serialize_dir / metric.name)</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.Session.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the session outputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Update the session outputs.&#34;&#34;&#34;
    for action in self._update_actions:
        action()
    self.call_callbacks(lambda h: h.on_update())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="experimenttools.sessions.SessionManager"><code class="flex name class">
<span>class <span class="ident">SessionManager</span></span>
<span>(</span><span>session, update_type='seconds', update_freq=60, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages the updating of a <code><a title="experimenttools.sessions.Session" href="#experimenttools.sessions.Session">Session</a></code>.</p>
<p>A <code><a title="experimenttools.sessions.SessionManager" href="#experimenttools.sessions.SessionManager">SessionManager</a></code> does not begin managing until <code>manage</code> is called.
At that point, it will continue managing until <code>close</code> is called.
Alternatively, the <code>SesssionManager</code> can be used as a context manager.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import experimenttools as et
&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; m0 = et.metrics.NumericMetric(&quot;m0&quot;)
&gt;&gt;&gt; session_dir = tempfile.mkdtemp()
&gt;&gt;&gt; session = et.Session(session_dir, metrics=[m0])
&gt;&gt;&gt; manager = et.SessionManager(session, update_type=&quot;updates&quot;)
&gt;&gt;&gt; _ = manager.manage()
&gt;&gt;&gt; for i in range(120):
...     m0(i) # m0 will be plotted and serialized every 60th update
&gt;&gt;&gt; manager.close()
</code></pre>
<p>As a context manager</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; with SessionManager(session, update_type=&quot;updates&quot;).manage():
...     for i in range(120):
...         m0(i)
&gt;&gt;&gt; m0(1) # Manager no longer managing the session
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; manager = SessionManager(session, update_type=&quot;updates&quot;)
&gt;&gt;&gt; with manager.manage():
...     for i in range(120):
...         m0(i)
</code></pre>
<p>Create a new session manager.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="experimenttools.sessions.Session" href="#experimenttools.sessions.Session">Session</a></code></dt>
<dd>The session to manage.</dd>
<dt><strong><code>update_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Either 'seconds' or 'updates'. If 'seconds', session will be
updated every <code>update_freq</code> seconds. If 'updates' session
will be updated every <code>update_freq</code> total updates to
metrics.</dd>
<dt><strong><code>update_freq</code></strong> :&ensp;<code>int</code></dt>
<dd>The frequency for updating the session.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>0, 1, or 2. 0 = silent, 1 = warnings, 2 = info.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionManager:
    &#34;&#34;&#34;Manages the updating of a `Session`.

    A `SessionManager` does not begin managing until `manage` is called.
    At that point, it will continue managing until `close` is called.
    Alternatively, the `SesssionManager` can be used as a context manager.

    Examples
    --------
    &gt;&gt;&gt; import experimenttools as et
    &gt;&gt;&gt; import tempfile
    &gt;&gt;&gt; m0 = et.metrics.NumericMetric(&#34;m0&#34;)
    &gt;&gt;&gt; session_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; session = et.Session(session_dir, metrics=[m0])
    &gt;&gt;&gt; manager = et.SessionManager(session, update_type=&#34;updates&#34;)
    &gt;&gt;&gt; _ = manager.manage()
    &gt;&gt;&gt; for i in range(120):
    ...     m0(i) # m0 will be plotted and serialized every 60th update
    &gt;&gt;&gt; manager.close()

    As a context manager
    &gt;&gt;&gt; with SessionManager(session, update_type=&#34;updates&#34;).manage():
    ...     for i in range(120):
    ...         m0(i)
    &gt;&gt;&gt; m0(1) # Manager no longer managing the session

    &gt;&gt;&gt; manager = SessionManager(session, update_type=&#34;updates&#34;)
    &gt;&gt;&gt; with manager.manage():
    ...     for i in range(120):
    ...         m0(i)

    &#34;&#34;&#34;

    def __init__(self, session, update_type=&#34;seconds&#34;, update_freq=60, verbose=0):
        &#34;&#34;&#34;Create a new session manager.

        Parameters
        ----------
        session: Session
                The session to manage.
        update_type: str
                Either &#39;seconds&#39; or &#39;updates&#39;. If &#39;seconds&#39;, session will be
                updated every `update_freq` seconds. If &#39;updates&#39; session
                will be updated every `update_freq` total updates to
                metrics.
        update_freq: int
                The frequency for updating the session.
        verbose: int
                0, 1, or 2. 0 = silent, 1 = warnings, 2 = info.

        &#34;&#34;&#34;
        self._verbose = verbose
        self._session = session
        self._managing = False
        self._session_callback = LambdaSessionCallback(
            on_metric_add=lambda m: m.add_callback(self.process_metric_update)
        )
        if update_type == &#34;seconds&#34;:
            self._last_update_seconds = time.time()
        elif update_type == &#34;updates&#34;:
            self._num_updates = 0
        else:
            raise ValueError(
                f&#34;Uknown value for parameter &#39;update_type&#39;: &#39;{update_type}&#39;&#34;
            )
        self._update_freq = update_freq
        self._log(2, f&#34;Session outputting to {self._session.output_dir}&#34;)

    def _log(self, level, msg):
        if self._verbose &gt;= level:
            print(f&#34;{datetime.now()}: expeexperimenttools.SessionManager] {msg}&#34;)

    def manage(self):
        &#34;&#34;&#34;Beginning managing the sesssion.

        Allows the manager to update the session when metrics are updated.

        Raises
        ------
        RuntimeError
                If the manager has already begun to manage the session.

        &#34;&#34;&#34;
        if self._managing:
            raise RuntimeError(&#34;SessionManager is already managing&#34;)
        self._log(2, &#34;Beginning management&#34;)
        self._managing = True
        self._session.add_callback(self._session_callback)
        for m in self._session.metrics:
            m.add_callback(self.process_metric_update)
        return self

    def close(self):
        &#34;&#34;&#34;Stop managing the session.

        The manager will no longer update the session when metrics have
        been updated.

        Raises
        ------
        RuntimeError
                If the manager is not currently managing the session.

        &#34;&#34;&#34;
        if not self._managing:
            raise RuntimeError(&#34;SessionManager is already closed&#34;)
        self._log(2, &#34;Ending management&#34;)
        self._session.remove_callback(self._session_callback)
        for m in self._session.metrics:
            m.remove_callback(self.process_metric_update)

    @property
    def session(self):
        &#34;&#34;&#34;Get the sesssion being managed.&#34;&#34;&#34;
        return self._session

    def __enter__(self):
        &#34;&#34;&#34;Use the session manager as a context manager.&#34;&#34;&#34;
        if not self._managing:
            raise RuntimeError(&#34;Use &#39;with manager.manage()&#39; for context management&#34;)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        &#34;&#34;&#34;Close the session manager upon exiting the context.&#34;&#34;&#34;
        self.close()

    def process_metric_update(self, _):
        &#34;&#34;&#34;Update the session if the update frequency has been reached.&#34;&#34;&#34;
        try:
            if time.time() - self._last_update_seconds &gt;= self._update_freq:
                self._log(2, &#34;Updating session&#34;)
                self._session.update()
                self._last_update_seconds = time.time()
        except AttributeError:
            if self._num_updates + 1 &gt;= self._update_freq:
                self._log(2, &#34;Updating session&#34;)
                self._session.update()
                self._num_updates = 0
            else:
                self._num_updates += 1</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="experimenttools.sessions.SessionManager.session"><code class="name">var <span class="ident">session</span></code></dt>
<dd>
<div class="desc"><p>Get the sesssion being managed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session(self):
    &#34;&#34;&#34;Get the sesssion being managed.&#34;&#34;&#34;
    return self._session</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="experimenttools.sessions.SessionManager.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop managing the session.</p>
<p>The manager will no longer update the session when metrics have
been updated.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the manager is not currently managing the session.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Stop managing the session.

    The manager will no longer update the session when metrics have
    been updated.

    Raises
    ------
    RuntimeError
            If the manager is not currently managing the session.

    &#34;&#34;&#34;
    if not self._managing:
        raise RuntimeError(&#34;SessionManager is already closed&#34;)
    self._log(2, &#34;Ending management&#34;)
    self._session.remove_callback(self._session_callback)
    for m in self._session.metrics:
        m.remove_callback(self.process_metric_update)</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.SessionManager.manage"><code class="name flex">
<span>def <span class="ident">manage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Beginning managing the sesssion.</p>
<p>Allows the manager to update the session when metrics are updated.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the manager has already begun to manage the session.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manage(self):
    &#34;&#34;&#34;Beginning managing the sesssion.

    Allows the manager to update the session when metrics are updated.

    Raises
    ------
    RuntimeError
            If the manager has already begun to manage the session.

    &#34;&#34;&#34;
    if self._managing:
        raise RuntimeError(&#34;SessionManager is already managing&#34;)
    self._log(2, &#34;Beginning management&#34;)
    self._managing = True
    self._session.add_callback(self._session_callback)
    for m in self._session.metrics:
        m.add_callback(self.process_metric_update)
    return self</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.SessionManager.process_metric_update"><code class="name flex">
<span>def <span class="ident">process_metric_update</span></span>(<span>self, _)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the session if the update frequency has been reached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_metric_update(self, _):
    &#34;&#34;&#34;Update the session if the update frequency has been reached.&#34;&#34;&#34;
    try:
        if time.time() - self._last_update_seconds &gt;= self._update_freq:
            self._log(2, &#34;Updating session&#34;)
            self._session.update()
            self._last_update_seconds = time.time()
    except AttributeError:
        if self._num_updates + 1 &gt;= self._update_freq:
            self._log(2, &#34;Updating session&#34;)
            self._session.update()
            self._num_updates = 0
        else:
            self._num_updates += 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="experimenttools.sessions.SessionServer"><code class="flex name class">
<span>class <span class="ident">SessionServer</span></span>
<span>(</span><span>sessions, output_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles serving of session files.</p>
<p>Allows for multiple sessions to be displayed on the same server. Gathers
the html files generated by each session and links them to an output
directory. Then, that directory can be served.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import experimenttools as et
&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; m0 = et.metrics.NumericMetric(&quot;m0&quot;)
&gt;&gt;&gt; session_dir = tempfile.mkdtemp()
&gt;&gt;&gt; server_dir = tempfile.mkdtemp()
&gt;&gt;&gt; session = et.Session(session_dir, name=&quot;sess&quot;, metrics=[m0])
&gt;&gt;&gt; server = et.SessionServer([session], server_dir)
&gt;&gt;&gt; for i in range(5):
...     m0(i)
&gt;&gt;&gt; session.plot() # Writes plots to 'experiment/index.html'
</code></pre>
<p>Then, run <code>python -m http.server --directory SERVER_DIR</code> to serve the
sessions while experiments are running. Or, do it programatically using
<code>server.serve()</code> at the end of the experiment.</p>
<p>Alternatively, you can pass in a list of
<code>(session_name, session_output_dir)</code> tuples to <code><a title="experimenttools.sessions.SessionServer" href="#experimenttools.sessions.SessionServer">SessionServer</a></code></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; session_spec = (session.name, session.output_dir)
&gt;&gt;&gt; server = et.SessionServer([session_spec], server_dir)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionServer:
    &#34;&#34;&#34;Handles serving of session files.

    Allows for multiple sessions to be displayed on the same server. Gathers
    the html files generated by each session and links them to an output
    directory. Then, that directory can be served.

    Examples
    --------
    &gt;&gt;&gt; import experimenttools as et
    &gt;&gt;&gt; import tempfile
    &gt;&gt;&gt; m0 = et.metrics.NumericMetric(&#34;m0&#34;)
    &gt;&gt;&gt; session_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; server_dir = tempfile.mkdtemp()
    &gt;&gt;&gt; session = et.Session(session_dir, name=&#34;sess&#34;, metrics=[m0])
    &gt;&gt;&gt; server = et.SessionServer([session], server_dir)
    &gt;&gt;&gt; for i in range(5):
    ...     m0(i)
    &gt;&gt;&gt; session.plot() # Writes plots to &#39;experiment/index.html&#39;

    Then, run `python -m http.server --directory SERVER_DIR` to serve the
    sessions while experiments are running. Or, do it programatically using
    `server.serve()` at the end of the experiment.

    Alternatively, you can pass in a list of
    `(session_name, session_output_dir)` tuples to `SessionServer`
    &gt;&gt;&gt; session_spec = (session.name, session.output_dir)
    &gt;&gt;&gt; server = et.SessionServer([session_spec], server_dir)

    &#34;&#34;&#34;

    def __init__(self, sessions, output_dir):
        self.output_dir = Path(output_dir)
        for session in sessions:
            self.add_session(session)

    def add_session(self, session):
        &#34;&#34;&#34;Add a session to the server.

        Parameters
        ----------
        session : Sesssion or (str, str)
                The `Session` to add. If passing in a `Session`, the session
                will be updated before it is added to ensure that its outputs
                have been created. If `(str, str)`, the first `str` should be
                the session name and the second should be the session output
                directory. Ensure that session has been updated if using this
                method.

        &#34;&#34;&#34;
        if isinstance(session, Session):
            if session.name is None:
                raise ValueError(
                    &#34;Sessions must have names to be added to a session server.&#34;
                )
            # Update the session so that index.html is generated
            session.update()
            sess_name = session.name
            sess_output_dir = session.output_dir
        else:
            sess_name, sess_output_dir = session
        self.output_dir.mkdir(exist_ok=True, parents=True)
        src_html_path = sess_output_dir / &#34;index.html&#34;
        dest_html_path = self.output_dir / f&#34;{sess_name}.html&#34;
        if dest_html_path.is_file():
            dest_html_path.unlink()
        os.link(src_html_path, dest_html_path)

    def serve(self, port=8000, bind=&#34;127.0.0.1&#34;):
        &#34;&#34;&#34;Start the server.

        Parameters
        ----------
        port: int
                The port to serve to.
        bind: str
                The bind address.

        &#34;&#34;&#34;
        output_dir = self.output_dir

        class DualStackServer(http.server.ThreadingHTTPServer):
            def server_bind(self):
                # suppress exception when protocol is IPv4
                with contextlib.suppress(Exception):
                    self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
                return super().server_bind()

            def finish_request(self, request, client_address):
                self.RequestHandlerClass(
                    request, client_address, self, directory=str(output_dir)
                )

        http.server.test(
            HandlerClass=http.server.SimpleHTTPRequestHandler,
            ServerClass=DualStackServer,
            port=port,
            bind=bind,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="experimenttools.sessions.SessionServer.add_session"><code class="name flex">
<span>def <span class="ident">add_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a session to the server.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code>Sesssion</code> or <code>(str, str)</code></dt>
<dd>The <code><a title="experimenttools.sessions.Session" href="#experimenttools.sessions.Session">Session</a></code> to add. If passing in a <code><a title="experimenttools.sessions.Session" href="#experimenttools.sessions.Session">Session</a></code>, the session
will be updated before it is added to ensure that its outputs
have been created. If <code>(str, str)</code>, the first <code>str</code> should be
the session name and the second should be the session output
directory. Ensure that session has been updated if using this
method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_session(self, session):
    &#34;&#34;&#34;Add a session to the server.

    Parameters
    ----------
    session : Sesssion or (str, str)
            The `Session` to add. If passing in a `Session`, the session
            will be updated before it is added to ensure that its outputs
            have been created. If `(str, str)`, the first `str` should be
            the session name and the second should be the session output
            directory. Ensure that session has been updated if using this
            method.

    &#34;&#34;&#34;
    if isinstance(session, Session):
        if session.name is None:
            raise ValueError(
                &#34;Sessions must have names to be added to a session server.&#34;
            )
        # Update the session so that index.html is generated
        session.update()
        sess_name = session.name
        sess_output_dir = session.output_dir
    else:
        sess_name, sess_output_dir = session
    self.output_dir.mkdir(exist_ok=True, parents=True)
    src_html_path = sess_output_dir / &#34;index.html&#34;
    dest_html_path = self.output_dir / f&#34;{sess_name}.html&#34;
    if dest_html_path.is_file():
        dest_html_path.unlink()
    os.link(src_html_path, dest_html_path)</code></pre>
</details>
</dd>
<dt id="experimenttools.sessions.SessionServer.serve"><code class="name flex">
<span>def <span class="ident">serve</span></span>(<span>self, port=8000, bind='127.0.0.1')</span>
</code></dt>
<dd>
<div class="desc"><p>Start the server.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port to serve to.</dd>
<dt><strong><code>bind</code></strong> :&ensp;<code>str</code></dt>
<dd>The bind address.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serve(self, port=8000, bind=&#34;127.0.0.1&#34;):
    &#34;&#34;&#34;Start the server.

    Parameters
    ----------
    port: int
            The port to serve to.
    bind: str
            The bind address.

    &#34;&#34;&#34;
    output_dir = self.output_dir

    class DualStackServer(http.server.ThreadingHTTPServer):
        def server_bind(self):
            # suppress exception when protocol is IPv4
            with contextlib.suppress(Exception):
                self.socket.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
            return super().server_bind()

        def finish_request(self, request, client_address):
            self.RequestHandlerClass(
                request, client_address, self, directory=str(output_dir)
            )

    http.server.test(
        HandlerClass=http.server.SimpleHTTPRequestHandler,
        ServerClass=DualStackServer,
        port=port,
        bind=bind,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="experimenttools" href="index.html">experimenttools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="experimenttools.sessions.Session" href="#experimenttools.sessions.Session">Session</a></code></h4>
<ul class="two-column">
<li><code><a title="experimenttools.sessions.Session.add_callback" href="#experimenttools.sessions.Session.add_callback">add_callback</a></code></li>
<li><code><a title="experimenttools.sessions.Session.add_metric" href="#experimenttools.sessions.Session.add_metric">add_metric</a></code></li>
<li><code><a title="experimenttools.sessions.Session.call_callbacks" href="#experimenttools.sessions.Session.call_callbacks">call_callbacks</a></code></li>
<li><code><a title="experimenttools.sessions.Session.metrics" href="#experimenttools.sessions.Session.metrics">metrics</a></code></li>
<li><code><a title="experimenttools.sessions.Session.plot" href="#experimenttools.sessions.Session.plot">plot</a></code></li>
<li><code><a title="experimenttools.sessions.Session.remove_callback" href="#experimenttools.sessions.Session.remove_callback">remove_callback</a></code></li>
<li><code><a title="experimenttools.sessions.Session.serialize" href="#experimenttools.sessions.Session.serialize">serialize</a></code></li>
<li><code><a title="experimenttools.sessions.Session.update" href="#experimenttools.sessions.Session.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="experimenttools.sessions.SessionManager" href="#experimenttools.sessions.SessionManager">SessionManager</a></code></h4>
<ul class="">
<li><code><a title="experimenttools.sessions.SessionManager.close" href="#experimenttools.sessions.SessionManager.close">close</a></code></li>
<li><code><a title="experimenttools.sessions.SessionManager.manage" href="#experimenttools.sessions.SessionManager.manage">manage</a></code></li>
<li><code><a title="experimenttools.sessions.SessionManager.process_metric_update" href="#experimenttools.sessions.SessionManager.process_metric_update">process_metric_update</a></code></li>
<li><code><a title="experimenttools.sessions.SessionManager.session" href="#experimenttools.sessions.SessionManager.session">session</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="experimenttools.sessions.SessionServer" href="#experimenttools.sessions.SessionServer">SessionServer</a></code></h4>
<ul class="">
<li><code><a title="experimenttools.sessions.SessionServer.add_session" href="#experimenttools.sessions.SessionServer.add_session">add_session</a></code></li>
<li><code><a title="experimenttools.sessions.SessionServer.serve" href="#experimenttools.sessions.SessionServer.serve">serve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>